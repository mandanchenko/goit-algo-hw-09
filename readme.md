Данні по часу алгоритмів:

Назва алгоритму         | Число                | Час алгоритму       
:---------------------- | :------------------- | :-------------------
Жадібний алгоритм       | 31                   | 2.4499997380189598e-05 |
Динамічне програмування | 31                   | 8.789999992586672e-05 |
Жадібний алгоритм       | 91                   | 6.499991286545992e-06 |
Динамічне програмування | 91                   | 0.00021610000112559646 |
Жадібний алгоритм       | 205                  | 5.900001269765198e-06 |
Динамічне програмування | 205                  | 0.0004859000036958605 |

Результати алгоритмів:

Жадібний алгоритм:\
31 {25: 1, 5: 1, 1: 1}\
91 {50: 1, 25: 1, 10: 1, 5: 1, 1: 1}\
205 {50: 4, 5: 1}\

Динамічне програмування:\
31 {25: 1, 5: 1, 1: 1}\ 
91 {50: 1, 25: 1, 10: 1, 5: 1, 1: 1}\
205 {50: 4, 5: 1}\

Як бачимо при знаходженні оптимального способу видачі решти обидва алгоритми дають однаковий результат. При цому
в випадку коли решта менше максимальної монети - жадібний алгоритм показує перевагу в часі. В інших випадках 
перевагу в часі має більш складне динамічне програмування.